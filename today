#!/usr/bin/env python3
#
# SPDX-FileCopyrightText: 2020 Sotiris Papatheodorou
# SPDX-License-Identifier: GPL-3.0-or-later

# TODO Add carry-todo option only for today
# TODO Accept a date range instead of FILE
# TODO Add version number

import argparse
import datetime
import os
import re
import subprocess
import sys

from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import List, Union



_date_format_file = '%Y%m%d'
_date_format_pretty = '%Y/%m/%d %A'
_help_desc_common = 'Keep a daily journal.'
_help_desc = {'today': "Edit today's journal file using VISUAL.",
    'yesterday': "Edit yesterday's journal file using VISUAL.",
    'tomorrow': "Edit tomorrow's journal file using VISUAL.",
    'lastday': "Edit the most recent journal file excluding today's file using VISUAL.",
    'week': "Render all the journal files for this week using PAGER.",
    'lastweek': "Render all the journal files for last week using PAGER.",
    'nextweek': "Render all the journal files for next week using PAGER."}
_help_epilog = '''The journal files are stored in the first directory
among $TODAYDIR, $XDG_DATA_HOME/today and $HOME/.local/share/today that
exists.'''



def journal_dir() -> str:
    """Return the journal directory"""
    if 'TODAYDIR' in os.environ:
        return os.environ['TODAYDIR']
    elif 'XDG_DATA_HOME' in os.environ:
        return os.environ['XDG_DATA_HOME'] + '/today'
    else:
        return os.environ['HOME'] + '/.local/share/today'



def editor() -> str:
    """Return the user's preferred text editor"""
    if 'VISUAL' in os.environ:
        return os.environ['VISUAL']
    elif 'EDITOR' in os.environ:
        return os.environ['EDITOR']
    else:
        return 'nano'



def pager() -> str:
    """Return the user's preferred pager"""
    if 'PAGER' in os.environ:
        return os.environ['PAGER']
    else:
        return 'less'



def printerr(*args, **kwargs) -> None:
    """Print to stderr prefixed with the program name"""
    error_prefix = os.path.basename(sys.argv[0]) + ': error:'
    print(error_prefix, *args, file=sys.stderr, **kwargs)



def ansi(style: str) -> str:
    """Return the corresponding ANSI escape sequence"""
    if not sys.stdout.isatty():
        return ''
    to_seq = {'normal': '0', 'bold': '1', 'dim': '2', 'italic': '3',
            'underline': '4', 'blink': '5', 'reverse': '7', 'crossout': '9',
            'black': '30', 'red': '31', 'green': '32', 'yellow': '33',
            'blue': '34', 'magenta': '35', 'cyan': '36', 'white': '37'}
    if style in to_seq:
        return ''.join(['\033[', to_seq[style], 'm'])
    else:
        return ''



def date_to_week(date: datetime.date) -> List[datetime.date]:
    """Get all the dates of the week the supplied date is part of"""
    week_start = date - datetime.timedelta(date.weekday())
    offsets = range(0, 7)
    return [week_start + datetime.timedelta(x) for x in offsets]



def str_to_date(s: str) -> Union[datetime.date, None]:
    """Convert a string in the format YYYYMMDD to a datetime.date"""
    if s.isdigit() and len(s) == 8:
        year = int(s[0:4])
        month = int(s[4:6])
        day = int(s[6:8])
        try:
            return datetime.date(year, month, day)
        except ValueError:
            return None
    else:
        return None



def last_date(suffix: str) -> List[datetime.date]:
    """Find the date of the latest journal that is not today's journal"""
    # Get the filenames of all journal files and remove the extensions
    _, _, filenames = next(os.walk(journal_dir()))
    filenames = [x[:-3] for x in filenames if x.endswith(suffix)]
    # Remove today's journal filename if it exists
    today_str = datetime.date.today().strftime(_date_format_file)
    if today_str in filenames:
        filenames.remove(today_str)
    # Return the latest day
    filenames.sort()
    if filenames:
        return [str_to_date(filenames[-1])]
    else:
        return []



def program_name_to_date_range(suffix: str) -> List[datetime.date]:
    """Create a list of dates based on the program name"""
    name = os.path.basename(sys.argv[0])
    today = datetime.date.today()
    if name == 'yesterday':
        return [today - datetime.timedelta(1)]
    elif name == 'tomorrow':
        return [today + datetime.timedelta(1)]
    elif name == 'lastday':
        return last_date(suffix)
    elif name == 'week':
        return date_to_week(today)
    elif name == 'lastweek':
        return date_to_week(today - datetime.timedelta(7))
    elif name == 'nextweek':
        return date_to_week(today + datetime.timedelta(7))
    else:
        return [today]



def dates_to_files(dates: List[datetime.date], suffix: str) -> List[str]:
    """Convert a list of dates to journal filenames"""
    files = []
    dir = journal_dir()
    for date in dates:
        files.append(dir + '/' + date.strftime(_date_format_file) + suffix)
    return files



def files_to_dates(files: List[str], suffix: str) -> List[datetime.date]:
    """Extract the dates from a list of filenames"""
    dates = []
    for file in files:
        if len(file) >= 11:
            date = str_to_date(file[-11:-len(suffix)])
            if date is not None:
                dates.append(date)
    return dates



def special_style(todo_header: str) -> str:
    return ''.join([ansi('bold'), ansi('red'), todo_header, ansi('normal')])



def header_style(header: str) -> str:
    return ''.join([ansi('bold'), ansi('blue'), header, ansi('normal')])



def day_header_style(day_header: str) -> str:
    return ''.join([ansi('bold'), ansi('yellow'), day_header, ansi('normal')])



def add_common_args(parser) -> None:
    parser.add_argument('-s', '--suffix', metavar='SUFFIX', default='.md',
            help='change the journal file suffix from .md to SUFFIX.')
    parser.add_argument('-S', '--special-regex', metavar='REGEX', default='^#+ TODO$',
            help='change the regular expression used to highlight special '
            'lines from \'^#+ TODO$\' to REGEX')



def process_common_args(args: argparse.Namespace) -> None:
    args.special_pattern = re.compile(args.special_regex)



def parse_args_show(name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
            description=' '.join([_help_desc_common, _help_desc[name]]),
            epilog=_help_epilog)
    parser.add_argument('filenames', metavar='FILE', nargs='*',
            help='open FILE instead of the journal for a specific date')
    add_common_args(parser)
    args = parser.parse_args()
    # Post-process arguments
    if args.filenames:
        # Extract the dates from the supplied filenames
        args.dates = files_to_dates(args.filenames, args.suffix)
    else:
        # Compute the dates to use based on the program name
        args.dates = program_name_to_date_range(args.suffix)
        # Extract the filenames from the dates
        args.filenames = dates_to_files(args.dates, args.suffix)
    process_common_args(args)
    return args



def parse_args_edit(name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
            description=' '.join([_help_desc_common, _help_desc[name]]),
            epilog=_help_epilog)
    parser.add_argument('date', metavar='YYYYMMDD', nargs='?',
            help='edit the journal for YYYYMMDD instead of the date inferred '
            'from the program name')
    add_common_args(parser)
    args = parser.parse_args()
    # Post-process arguments
    if args.date is not None:
        # A date was given as an argument, use it
        args.dates = [str_to_date(args.date)]
        if args.dates[0] is None:
            printerr('Invalid date format, expected YYYYMMDD')
            sys.exit(2)
    else:
        # Compute the dates to use based on the program name
        args.dates = program_name_to_date_range(args.suffix)
    # Extract the filenames from the dates
    args.filenames = dates_to_files(args.dates, args.suffix)
    process_common_args(args)
    return args



def show_dates(args: argparse.Namespace) -> None:
    """Show all the journals for the supplied dates in the user's preferred pager"""
    # Write to the stdin of the pager directly
    with subprocess.Popen([pager(), '-R'], stdin=subprocess.PIPE, universal_newlines=True) as p:
        # Create a header with the date range if applicable
        if len(args.dates) > 1:
            start_date = args.dates[0].strftime(_date_format_pretty)
            end_date = args.dates[-1].strftime(_date_format_pretty)
            header = ''.join([start_date, ' - ', end_date, '\n\n'])
            header = header_style(header)
            p.stdin.write(header)
        # Loop over each day and output the contents of the respective file if
        # it exists
        for idx, day in enumerate(args.dates):
            filename = args.filenames[idx]
            if os.path.exists(filename):
                with open(filename) as f:
                    day_header = ''.join([day.strftime(_date_format_pretty), '\n\n'])
                    day_header = day_header_style(day_header)
                    p.stdin.write(day_header)
                    for line in f:
                        if args.special_pattern.match(line) is not None:
                            line = special_style(line)
                        p.stdin.write(line)
                    p.stdin.write('\n\n')



def edit_date(args: argparse.Namespace) -> None:
    """Open the journal for a single date in the user's preferred text editor"""
    # Create the journal directory
    Path(journal_dir()).mkdir(parents=True, exist_ok=True)
    filename = args.filenames[0]
    result = subprocess.run([editor(), filename], stderr=subprocess.PIPE)
    if result.returncode != 0:
        printerr('subprocess error')
        if result.stdout:
            print(result.stdout, file=sys.stderr)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
    # Delete the journal file if it's empty
    remove = False
    with open(filename) as f:
        data = f.read().strip()
        if not data:
            remove = True
    if remove:
        os.remove(filename)



if __name__ == "__main__":
    name = os.path.basename(sys.argv[0])
    if name in ['week', 'lastweek', 'nextweek']:
        args = parse_args_show(name)
        show_dates(args)
    else:
        args = parse_args_edit(name)
        edit_date(args)

