#!/usr/bin/env python3
#
# SPDX-FileCopyrightText: 2020-2021 Sotiris Papatheodorou
# SPDX-License-Identifier: GPL-3.0-or-later

# TODO Accept a date range instead of FILE

import argparse
import datetime
import os
import re
import subprocess
import sys

from pathlib import Path
from tempfile import NamedTemporaryFile
from typing import List, Union



_version = "1.1.2"
_date_format_file = '%Y%m%d'
_date_format_pretty = '%Y/%m/%d %A'
_help_desc_common = 'Keep a daily journal.'
_help_desc = {'today': "Edit today's journal file using VISUAL.",
    'yesterday': "Edit yesterday's journal file using VISUAL.",
    'tomorrow': "Edit tomorrow's journal file using VISUAL.",
    'prevday': "Edit the most recent journal file excluding today's file using VISUAL.",
    'nextday': "Edit the closest future journal file using VISUAL.",
    'week': "Render all the journal files for this week using PAGER.",
    'prevweek': "Render all the journal files for the previous week using PAGER.",
    'nextweek': "Render all the journal files for the next week using PAGER."}
_help_epilog = '''The journal files are stored in the first directory
among $TODAYDIR, $XDG_DATA_HOME/today and $HOME/.local/share/today that
exists.'''



def journal_dir() -> str:
    """Return the journal directory"""
    if 'TODAYDIR' in os.environ:
        return os.environ['TODAYDIR']
    elif 'XDG_DATA_HOME' in os.environ:
        return os.environ['XDG_DATA_HOME'] + '/today'
    else:
        return os.environ['HOME'] + '/.local/share/today'



def editor() -> str:
    """Return the user's preferred text editor"""
    if 'VISUAL' in os.environ:
        return os.environ['VISUAL']
    elif 'EDITOR' in os.environ:
        return os.environ['EDITOR']
    else:
        return 'nano'



def pager() -> str:
    """Return the user's preferred pager"""
    if 'PAGER' in os.environ:
        return os.environ['PAGER']
    else:
        return 'less'



def journal_suffix() -> str:
    """Return the journal file suffix"""
    if 'TODAY_SUFFIX' in os.environ:
        return os.environ['TODAY_SUFFIX']
    else:
        return '.md'



def special_regex() -> str:
    """Return the regex used to highlight special lines"""
    if 'TODAY_SPECIAL_REGEX' in os.environ:
        return os.environ['TODAY_SPECIAL_REGEX']
    else:
        return '^#+ TODO$'



def printerr(*args, **kwargs) -> None:
    """Print to stderr prefixed with the program name"""
    error_prefix = os.path.basename(sys.argv[0]) + ': error:'
    print(error_prefix, *args, file=sys.stderr, **kwargs)



def ansi(style: str) -> str:
    """Return the corresponding ANSI escape sequence"""
    if not sys.stdout.isatty():
        return ''
    to_seq = {'normal': '0', 'bold': '1', 'dim': '2', 'italic': '3',
            'underline': '4', 'blink': '5', 'reverse': '7', 'crossout': '9',
            'black': '30', 'red': '31', 'green': '32', 'yellow': '33',
            'blue': '34', 'magenta': '35', 'cyan': '36', 'white': '37'}
    if style in to_seq:
        return ''.join(['\033[', to_seq[style], 'm'])
    else:
        return ''



def date_to_week(date: datetime.date) -> List[datetime.date]:
    """Get all the dates of the week the supplied date is part of"""
    week_start = date - datetime.timedelta(date.weekday())
    offsets = range(0, 7)
    return [week_start + datetime.timedelta(x) for x in offsets]



def str_to_date(s: str) -> Union[datetime.date, None]:
    """Convert a string in the format YYYYMMDD to a datetime.date"""
    if s.isdigit() and len(s) == 8:
        year = int(s[0:4])
        month = int(s[4:6])
        day = int(s[6:8])
        try:
            return datetime.date(year, month, day)
        except ValueError:
            return None
    else:
        return None



def prev_date(suffix: str) -> List[datetime.date]:
    """Find the date of the latest journal that is not today's journal"""
    # Get the filenames of all journal files and remove the extensions
    _, _, filenames = next(os.walk(journal_dir()))
    dates_str = [x[:-3] for x in filenames if x.endswith(suffix)]
    # Remove all dates corresponding to today or in the future
    today_str = datetime.date.today().strftime(_date_format_file)
    dates_str = [d for d in dates_str if d < today_str]
    # Return the latest day
    dates_str.sort()
    if dates_str:
        return [str_to_date(dates_str[-1])]
    else:
        return []



def next_date(suffix: str) -> List[datetime.date]:
    """Find the date of the next journal that is not today's journal"""
    # Get the filenames of all journal files and remove the extensions
    _, _, filenames = next(os.walk(journal_dir()))
    dates_str = [x[:-3] for x in filenames if x.endswith(suffix)]
    # Remove all dates corresponding to today or in the past
    today_str = datetime.date.today().strftime(_date_format_file)
    dates_str = [d for d in dates_str if d > today_str]
    # Return the oldest day
    dates_str.sort()
    if dates_str:
        return [str_to_date(dates_str[0])]
    else:
        return []



def program_name_to_date_range(suffix: str) -> List[datetime.date]:
    """Create a list of dates based on the program name"""
    name = os.path.basename(sys.argv[0])
    today = datetime.date.today()
    if name == 'yesterday':
        return [today - datetime.timedelta(1)]
    elif name == 'tomorrow':
        return [today + datetime.timedelta(1)]
    elif name == 'prevday':
        return prev_date(suffix)
    elif name == 'nextday':
        return next_date(suffix)
    elif name == 'week':
        return date_to_week(today)
    elif name == 'prevweek':
        return date_to_week(today - datetime.timedelta(7))
    elif name == 'nextweek':
        return date_to_week(today + datetime.timedelta(7))
    else:
        return [today]



def dates_to_files(dates: List[datetime.date], suffix: str) -> List[str]:
    """Convert a list of dates to journal filenames"""
    files = []
    dir = journal_dir()
    for date in dates:
        files.append(dir + '/' + date.strftime(_date_format_file) + suffix)
    return files



def files_to_dates(files: List[str], suffix: str) -> List[datetime.date]:
    """Extract the dates from a list of filenames"""
    dates = []
    for file in files:
        if len(file) >= 11:
            date = str_to_date(file[-11:-len(suffix)])
            if date is not None:
                dates.append(date)
    return dates



def special_style(todo_header: str) -> str:
    return ''.join([ansi('bold'), ansi('red'), todo_header, ansi('normal')])



def header_style(header: str) -> str:
    return ''.join([ansi('bold'), ansi('blue'), header, ansi('normal')])



def day_header_style(day_header: str) -> str:
    return ''.join([ansi('bold'), ansi('yellow'), day_header, ansi('normal')])



def add_common_args(parser) -> None:
    parser.add_argument('-V', '--version', action='version',
            version='%(prog)s ' + _version)



def process_common_args(args: argparse.Namespace) -> None:
    args.suffix = journal_suffix()
    args.special_pattern = re.compile(special_regex())



def parse_args_show(name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
            description=' '.join([_help_desc_common, _help_desc[name]]),
            epilog=_help_epilog)
    parser.add_argument('filenames', metavar='FILE', nargs='*',
            help='open FILE instead of the journal for a specific date')
    add_common_args(parser)
    args = parser.parse_args()
    # Post-process arguments
    process_common_args(args)
    if args.filenames:
        # Extract the dates from the supplied filenames
        args.dates = files_to_dates(args.filenames, args.suffix)
    else:
        # Compute the dates to use based on the program name
        args.dates = program_name_to_date_range(args.suffix)
        # Extract the filenames from the dates
        args.filenames = dates_to_files(args.dates, args.suffix)
    return args



def parse_args_edit(name: str) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
            description=' '.join([_help_desc_common, _help_desc[name]]),
            epilog=_help_epilog)
    parser.add_argument('date', metavar='YYYYMMDD', nargs='?',
            help='edit the journal for YYYYMMDD instead of the date inferred '
            'from the program name')
    if os.path.basename(sys.argv[0]) == 'today':
        parser.add_argument('-c', '--carry-regex', metavar='REGEX', nargs='?',
                const='^#+ TODO$', default=None,
                help='move all text between the line matching the REGEX and '
                'the end of the file inclusive from the "prevday" to the '
                '"today" file. The default REGEX is \'^#+ TODO$\'')
    add_common_args(parser)
    args = parser.parse_args()
    # Post-process arguments
    process_common_args(args)
    if os.path.basename(sys.argv[0]) == 'today' and args.carry_regex is not None:
        args.carry_regex = re.compile(args.carry_regex)
    else:
        args.carry_regex = None
    if args.date is not None:
        # A date was given as an argument, use it
        args.dates = [str_to_date(args.date)]
        if args.dates[0] is None:
            printerr('Invalid date format, expected YYYYMMDD')
            sys.exit(2)
    else:
        # Compute the dates to use based on the program name
        args.dates = program_name_to_date_range(args.suffix)
    # Extract the filenames from the dates
    args.filenames = dates_to_files(args.dates, args.suffix)
    return args



def get_before_regex(filename: str, regex: re.Pattern) -> str:
    """Return all lines of filename from the first line up to the last not
    matching the regex.
    """
    lines = []
    after_regex = False
    with open(filename) as f:
        for line in f:
            if args.carry_regex.match(line) is not None:
                after_regex = True
            if not after_regex:
                lines.append(line)
    text = ''.join(lines).rstrip()
    # Keep only a single trailing newline
    if text:
        text += '\n\n'
    return text



def get_after_regex(filename: str, regex: re.Pattern) -> str:
    """Return all lines of filename from the first line matching the regex."""
    lines = []
    after_regex = False
    with open(filename) as f:
        for line in f:
            if args.carry_regex.match(line) is not None:
                after_regex = True
            if after_regex:
                lines.append(line)
    return ''.join(lines)



def show_dates(args: argparse.Namespace) -> None:
    """Show all the journals for the supplied dates in the user's preferred pager"""
    # Write to the stdin of the pager directly
    with subprocess.Popen([pager(), '-R'], stdin=subprocess.PIPE, universal_newlines=True) as p:
        # Create a header with the date range if applicable
        if len(args.dates) > 1:
            start_date = args.dates[0].strftime(_date_format_pretty)
            end_date = args.dates[-1].strftime(_date_format_pretty)
            header = ''.join([start_date, ' - ', end_date, '\n\n'])
            header = header_style(header)
            p.stdin.write(header)
        # Loop over each day and output the contents of the respective file if
        # it exists
        for idx, day in enumerate(args.dates):
            filename = args.filenames[idx]
            if os.path.exists(filename):
                with open(filename) as f:
                    day_header = ''.join([day.strftime(_date_format_pretty), '\n\n'])
                    day_header = day_header_style(day_header)
                    p.stdin.write(day_header)
                    for line in f:
                        if args.special_pattern.match(line) is not None:
                            line = special_style(line)
                        p.stdin.write(line)
                    p.stdin.write('\n\n')



def edit_date(args: argparse.Namespace) -> None:
    """Open the journal for a single date in the user's preferred text editor"""
    if not args.filenames:
        printerr("No files to edit.")
        sys.exit(1)
    # Create the journal directory
    Path(journal_dir()).mkdir(parents=True, exist_ok=True)
    filename = args.filenames[0]
    # Carry over content from prevday
    should_carry = args.carry_regex is not None
    if should_carry:
        prevday_filename = dates_to_files(prev_date(args.suffix), args.suffix)[0]
        carried_content = get_after_regex(prevday_filename, args.carry_regex)
        # Append prevday's content to today's file
        if carried_content:
            with open(filename, 'a') as f:
                f.write('\n\n\n')
                f.write(carried_content)
        # Remove the carried content from the previous file
        left_content = get_before_regex(prevday_filename, args.carry_regex)
        with open(prevday_filename, 'w') as f:
            f.write(left_content)
    result = subprocess.run([editor(), filename], stderr=subprocess.PIPE)
    success = result.returncode == 0
    if not success:
        printerr('subprocess error')
        if result.stdout:
            print(result.stdout, file=sys.stderr)
        if result.stderr:
            print(result.stderr, file=sys.stderr)
    # Delete the journal file if it's empty
    remove = False
    if os.path.isfile(filename):
        with open(filename) as f:
            data = f.read().strip()
            if not data:
                remove = True
    if remove:
        os.remove(filename)



if __name__ == "__main__":
    name = os.path.basename(sys.argv[0])
    if name in ['week', 'prevweek', 'nextweek']:
        args = parse_args_show(name)
        show_dates(args)
    else:
        args = parse_args_edit(name)
        edit_date(args)

